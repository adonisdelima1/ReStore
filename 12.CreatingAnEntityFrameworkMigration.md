# Creating an entity framework migration file
1. Inside your appsettings.development.json, if there's not any attribute called ``ConnectionStrings``, only ``Logging`` for example, create a property for connection strings and inside ``ConnectionStrings`` object value, create one property called ``DefaultConnection``. 
2. Before we continue the implementation of the connection string, we need to create the migration responsible to create the code that creates our database, so in this point we don't have a database yet 
3. Run command ``dotnet tool install --global dotnet-ef --version 7.0.8`` on terminal to install EF NuGet globally (**reminder**: google for an ef tool (the string can be "dotnet ef nuget 7.0.8") that fits your .net **runtime(s)** version, run ``dotnet --info`` or ``dotnet --list-runtimes`` to check it). Be sure your project packages (ms.efcore.sqlite and ms.efcore.design are the same version number as well)
4. Run ``dotnet tool list -g`` to check **dotnet-ef** installation 
5. Run ``dotnet ef`` to see available options to use along this command 
6. Remember to stop your API if it's runnning, and be sure your prompt/bash/shell instance is inside API project folder 
7. Run this on terminal/bash/shell ``dotnet ef migrations add InitialCreate -o Data/Migrations``. We are requesting our EF NuGet to create a new migration called **InitialCreate** and the file's address/path should be inside Data/Migrations directory. 
8. There should be 3 new files in API/Data/Migrations directory: (1) StoreContextModelSnapshot.cs, (2) InitialCreate.Designer.cs and (3) InitialCreate.cs, the most important to us (devs). ``InitialCreate`` class inherits/extends/derives from Migration type/class. It has one method called ``Up()`` and the other called ``Down()``. when ``Up()`` is executed it calls a builder method named ``CreateTable()`` that creates a SQL table called **Products** that has the same columns of our ``Product`` class' attributes. And because we declared an ``int`` property called ``Id``, Entity Framework assumes that this is going to be the table's primary key with autoincrement pattern. That's why we say that Entity Framework is **convention based**. When ``Down()`` is called it calls a builder method named ``DropTable()`` that basically drops any table that has **Products** as its name. 
9. Now that migration classes are created we need to finally create our database running the bash/shell/terminal command ``dotnet ef database update``. After running this, the success scenary is that there's new file called **store.db** on your project's root. 
10. Show all commands (Ctrl + Shift + P) and look for "**SQLite: Open Database**" and open the store.db file on SQLite's explorer. There should be two tables, one for **Products** and other called something like **_EFMigrationsHistory**. 



**REMINDER** if you want to uninstall a tool (globally): 
1. ``dotnet tool list -g`` to get the package's name and then ``dotnet tool uninstall <PACKAGE_NAME> -g`` to uninstall it.                
   
      
           
**Continues on [13.CreatingClassToSeedDataIntoDb](./13.CreatingClassToSeedDataIntoDb.md)**




